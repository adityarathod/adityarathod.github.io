{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    code: \"code\",\n    h4: \"h4\",\n    pre: \"pre\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components), {Image, MultiCode} = _components;\n  if (!Image) _missingMdxReference(\"Image\", true);\n  if (!MultiCode) _missingMdxReference(\"MultiCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsxs(_components.em, {\n        children: [\"This article has been mentioned in the media: \", _jsx(_components.a, {\n          href: \"https://www.theverge.com/2017/12/25/16817502/how-to-stop-hq-cheaters\",\n          children: \"The Verge\"\n        }), \", \", _jsx(_components.a, {\n          href: \"https://www.washingtonpost.com/graphics/2018/business/hq-trivia/\",\n          children: \"Washington Post\"\n        }), \", and \", _jsx(_components.a, {\n          href: \"https://techcrunch.com/2018/03/06/hq-trivia-questions/\",\n          children: \"TechCrunch\"\n        })]\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Mobile trivia apps\"\n      }), \", such as HQ Trivia and The Q, modernize game show-style entertainment, allowing anyone to try their hand at winning cash prizes from their smartphone from anywhere. However, these applications are susceptible to cheaters and bots. For example, \", _jsx(_components.a, {\n        href: \"https://medium.com/@tobymellor/hq-trivia-using-bots-to-win-money-from-online-game-shows-ce2a1b11828b\",\n        children: \"a developer by the name of Toby Mellor\"\n      }), \" recently demonstrated how he created a near-realtime system to cheat on HQ Trivia. His post (linked above) details his use of Google cloud APIs to create this system.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"While the demo was certainly impressive, I felt that I could improve on this system as a proof-of-concept. Armed with his post, I set out to make a better version of his system. However, I set some constraints on myself to make this more of a challenge:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"The system must run offline, with the exception of the QAS (question-and-answer system).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The system allow a human enough time to tap in the answer.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The system should require minimal human intervention, since a human will be using the system in real time.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The system must be functional within one hour.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Creating a Trivia-Cheating System\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Design\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Instead of doing fancy (and slow) network-request hijacking using \", _jsx(_components.code, {\n        children: \"mitmproxy\"\n      }), \", I decided to run OCR at intervals on a portion of the image coming from the phone and pipe that to Google to provide a quick answer for the human operator to tap in. The system looks something like the following:\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/post-images/trivia-diagram-2.png\",\n      width: 700,\n      height: 85,\n      className: \"mx-auto\",\n      layout: \"responsive\",\n      alt: \"trivia diagram\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TL;DR: a region of the iPhone's screen will get captured, put through OCR, and then searched up on Google to get an answer.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Implementation\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Capturing the Screen\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, I needed a way to capture only a region of the QuickTime window on my Mac into a temp file. That turned out to be trivial using the excellent CLI \", _jsx(_components.code, {\n        children: \"screencapture\"\n      }), \" tool.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I initially used interactive selection, where the user manually makes a rectangular selection to capture:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"screencapture -ci screens.png\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, I quickly realized that was extremely inefficient and that hardcoding in rect coordinates (a feature \", _jsx(_components.code, {\n        children: \"screencapture\"\n      }), \" supports) was a much better option:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \" screencapture -Rx,y,w,h screens.png\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Note:\"\n      }), \" The rect coordinates are in the form \", _jsx(_components.code, {\n        children: \"x,y,w,h\"\n      }), \", with \", _jsx(_components.code, {\n        children: \"(x, y)\"\n      }), \" being the coordinate of the top left corner.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Optical Character Recognition\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It was time to find a passable OCR system that was fast and accurate. The only one I could think of was \", _jsx(_components.a, {\n        href: \"https://github.com/tesseract-ocr/tesseract\",\n        children: _jsx(_components.code, {\n          children: \"tesseract\"\n        })\n      }), \", an OCR engine maintained by Google. While not the best system in the world, its functionality out of the box was pretty great in my testing.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In order to extract text from our image using Tesseract, I used the following,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"tesseract screens.png ocr\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"which takes the image and puts the extracted text into a file, \", _jsx(_components.code, {\n        children: \"ocr.txt\"\n      }), \". Now, it's finally time to answer this question.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Constructing a Google Search URL and Launching Chrome\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One little nasty step we have to do is to put our URL-encoded search query into a Google Search URL and then push that URL to a browser of choice (I used Google Chrome). I used Python for this step because of its familiarity.\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"URL Encoding the Search Query\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A typical Google search URL looks something like this:\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"https://www.google.com/search&q=what+is+life%3F\",\n            children: \"https://www.google.com/search&q=what+is+life%3F\"\n          })\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Notice how the search query is a query string, the spaces are replaced with \", _jsx(_components.code, {\n        children: \"+\"\n      }), \" signs, and special characters are encoded. Python 3 can do this easily with \", _jsx(_components.code, {\n        children: \"urllib.parse.quote_plus(str)\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So our code might look something like this:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"query_encoded = urllib.parse.quote_plus(query)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Programmatically Launching Chrome\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, we need to pass the URL to Chrome programmatically. With a little bit of trial and error, I found out that the Unix binary, located at \", _jsx(_components.code, {\n        children: \"/Applications/Google\\\\ Chrome.app/Contents/MacOS/Google\\\\ Chrome\"\n      }), \", can open URLs without launching a new browser instance. Using that to our advantage, we simply pass the URL as a shell argument, and \", _jsx(_components.em, {\n        children: \"violà!\"\n      }), \" It works.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Stitching These Components Together\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, it's time to mesh these components together. I decided to keep it simple and created a shell script to run each component and pass around data. My shell script ended up looking like this:\"\n    }), \"\\n\", _jsx(MultiCode, {\n      tabs: [{\n        name: \"realtime-ocr.bash\",\n        content: `#!/usr/local/bin/zsh\necho \"Realtime Screen OCR\"\nwhile true\ndo\n    echo \"Waiting for trigger\"\n    read\n    screencapture -Rx,y,w,h screens.png\n    tesseract screens.png ocr\n    OCR=\\`cat ocr.txt\\`\n    python3 launch.py $OCR\n    echo \"Opened Chrome...waiting for next question\"\ndone`,\n        language: \"bash\"\n      }]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The script waits for the enter key, grabs the predefined rect, runs OCR on it, and then launches Chrome. Then, it goes back to waiting for the enter key.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Testing and Debrief\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I ran tests on this system using video replays of previous HQ Trivia shows. It worked well but struggled on the more difficult questions. Here's a video of the system providing an instant answer to a question:\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"iframe\", {\n        width: \"560\",\n        height: \"315\",\n        src: \"https://www.youtube-nocookie.com/embed/F1m6ZyqIvhs?rel=0\",\n        frameborder: \"0\",\n        allow: \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\",\n        allowfullscreen: true\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In my opinion, this checks all the boxes–it works offline, it's fast, and it's pretty much self-sufficient.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, it's not always 100% accurate. This is because I didn't develop an \", _jsx(_components.em, {\n        children: \"actual\"\n      }), \" QAS system that breaks down sentence structure using NLP and then searches for detected entities within a corpus. But this shows that \", _jsx(_components.em, {\n        children: \"it's possible to build something like this.\"\n      }), \" This system took me one hour to build from planning to completion; somebody with more time and dedication could build something even more accurate and scam the companies behind these apps for thousands of dollars.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Defending Against Cheaters\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Preventing people from cheating, especially on devices they own, is extremely difficult. \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Sony_BMG_copy_protection_rootkit_scandal\",\n        children: \"It's also quite difficult to do right.\"\n      }), \" The dev mentioned in the Introduction, Toby Mellor, suggests a software check for screen capture devices. While a good first step, this doesn't really prevent alternative methods of screen capture (such as just straight-up filming the screen with another camera). I suggest \", _jsx(_components.em, {\n        children: \"fooling the underlying algorithms underneath\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\"How do you do this\\\", you may ask? The answer is \", _jsx(_components.em, {\n        children: \"adversarial perturbations\"\n      }), \", a term coined by Evtimov et al. in the paper \", _jsx(_components.em, {\n        children: _jsx(_components.a, {\n          href: \"https://arxiv.org/abs/1707.08945\",\n          children: \"Robust Physical-World Attacks on Deep Learning Models\"\n        })\n      }), \". By making the text harder to be read by a bot, you are esssentially rate-limiting cheating. So how would this look like in practice? Maybe something like this, which completely fooled Tesseract:\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/post-images/hq-fooled.png\",\n      width: 400,\n      height: 500,\n      className: \"mx-auto\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(Well, not exactly that. That picture is quite horrible aesthetically)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HQ needs to take advantage of its animated aesthetic and add a pattern, different fonts, particle effects, or something similar to confuse OCR systems.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There's already been research into how to fool OCR systems, such as this \", _jsx(_components.a, {\n        href: \"https://walkerart.org/magazine/sang-mun-defiant-typeface-nsa-privacy\",\n        children: \"OCR-resistant font\"\n      }), \", but I think that with the advent of deep learning, nothing short of overlaying/blending unpredictable patterns will prevent determined attackers from developing systems to cheat.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://news.ycombinator.com/item?id=15944171\",\n        children: \"Discuss on Hacker News\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Protecting Trivia Apps from Cheaters","description":"How people cheat at trivia games, and how the companies running them could stop this from happening.","displayDate":"December 16, 2017","date":1513472400000,"tags":["Legacy Content"]}},"frontMatter":{"title":"Protecting Trivia Apps from Cheaters","description":"How people cheat at trivia games, and how the companies running them could stop this from happening.","displayDate":"December 16, 2017","date":1513472400000,"tags":["Legacy Content"]}},"__N_SSG":true}