_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[11],{"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n("q1tI"),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):i(i({},t),e)),n},b=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),b=p(n),u=a,m=b["".concat(s,".").concat(u)]||b[u]||h[u]||o;return n?r.a.createElement(m,i(i({ref:t},l),{},{components:n})):r.a.createElement(m,i({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"===typeof e||a){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"===typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,"a",(function(){return a}))},GUIJ:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/protect-trivia-from-bots",function(){return n("Y9OF")}])},Qetd:function(e,t,n){"use strict";var a=Object.assign.bind(Object);e.exports=a,e.exports.default=e.exports},Y9OF:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n("rePB"),r=n("Ff2n"),o=(n("q1tI"),n("7ljp"));function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){Object(a.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var c={title:"Protecting Trivia Apps from Cheaters",description:"How people cheat at trivia games, and how the companies running them could stop this from happening.",date:"December 16, 2017",draft:!1,hasMath:!1,pubTime:"2017-12-17T01:00:00Z"},l={frontMatter:c};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",i(i(i({},l),n),{},{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"This article has been mentioned in the media: ",Object(o.b)("a",i({parentName:"em"},{href:"https://www.theverge.com/2017/12/25/16817502/how-to-stop-hq-cheaters"}),"The Verge"),", ",Object(o.b)("a",i({parentName:"em"},{href:"https://www.washingtonpost.com/graphics/2018/business/hq-trivia/"}),"Washington Post"),", and ",Object(o.b)("a",i({parentName:"em"},{href:"https://techcrunch.com/2018/03/06/hq-trivia-questions/"}),"TechCrunch")),"."),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Mobile trivia apps"),", such as HQ Trivia and The Q, modernize game show-style entertainment, allowing anyone to try their hand at winning cash prizes from their smartphone from anywhere. However, these applications are susceptible to cheaters and bots. For example, ",Object(o.b)("a",i({parentName:"p"},{href:"https://medium.com/@tobymellor/hq-trivia-using-bots-to-win-money-from-online-game-shows-ce2a1b11828b"}),"a developer by the name of Toby Mellor")," recently demonstrated how he created a near-realtime system to cheat on HQ Trivia. His post (linked above) details his use of Google cloud APIs to create this system."),Object(o.b)("p",null,"While the demo was certainly impressive, I felt that I could improve on this system as a proof-of-concept. Armed with his post, I set out to make a better version of his system. However, I set some constraints on myself to make this more of a challenge:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The system must run offline, with the exception of the QAS (question-and-answer system)."),Object(o.b)("li",{parentName:"ul"},"The system allow a human enough time to tap in the answer."),Object(o.b)("li",{parentName:"ul"},"The system should require minimal human intervention, since a human will be using the system in real time."),Object(o.b)("li",{parentName:"ul"},"The system must be functional within one hour.")),Object(o.b)("h2",null,"Creating a Trivia-Cheating System"),Object(o.b)("h3",null,"Design"),Object(o.b)("p",null,"Instead of doing fancy (and slow) network-request hijacking using ",Object(o.b)("inlineCode",{parentName:"p"},"mitmproxy"),", I decided to run OCR at intervals on a portion of the image coming from the phone and pipe that to Google to provide a quick answer for the human operator to tap in. The system looks something like the following:"),Object(o.b)("center",null,Object(o.b)("img",{src:"/static/img/trivia-diagram.svg",alt:"System diagram"})),Object(o.b)("p",null,"TL;DR: a region of the iPhone's screen will get captured, put through OCR, and then searched up on Google to get an answer."),Object(o.b)("h3",null,"Implementation"),Object(o.b)("h4",null,"Capturing the Screen"),Object(o.b)("p",null,"First, I needed a way to capture only a region of the QuickTime window on my Mac into a temp file. That turned out to be trivial using the excellent CLI ",Object(o.b)("inlineCode",{parentName:"p"},"screencapture")," tool."),Object(o.b)("p",null,"I initially used interactive selection, where the user manually makes a rectangular selection to capture:"),Object(o.b)("pre",i({},{className:"language-bash"}),Object(o.b)("code",i({parentName:"pre"},{className:"language-bash"}),"screencapture -ci screens.png\n")),Object(o.b)("p",null,"However, I quickly realized that was extremely inefficient and that hardcoding in rect coordinates (a feature ",Object(o.b)("inlineCode",{parentName:"p"},"screencapture")," supports) was a much better option:"),Object(o.b)("pre",i({},{className:"language-bash"}),Object(o.b)("code",i({parentName:"pre"},{className:"language-bash"})," screencapture -Rx,y,w,h screens.png\n")),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"Note:")," The rect coordinates are in the form ",Object(o.b)("inlineCode",{parentName:"p"},"x,y,w,h"),", with ",Object(o.b)("inlineCode",{parentName:"p"},"(x, y)")," being the coordinate of the top left corner."),Object(o.b)("h4",null,"Optical Character Recognition"),Object(o.b)("p",null,"It was time to find a passable OCR system that was fast and accurate. The only one I could think of was ",Object(o.b)("a",i({parentName:"p"},{href:"https://github.com/tesseract-ocr/tesseract"}),Object(o.b)("inlineCode",{parentName:"a"},"tesseract")),", an OCR engine maintained by Google. While not the best system in the world, its functionality out of the box was pretty great in my testing."),Object(o.b)("p",null,"In order to extract text from our image using Tesseract, I used the following,"),Object(o.b)("pre",i({},{className:"language-bash"}),Object(o.b)("code",i({parentName:"pre"},{className:"language-bash"}),"tesseract screens.png ocr\n")),Object(o.b)("p",null,"which takes the image and puts the extracted text into a file, ",Object(o.b)("inlineCode",{parentName:"p"},"ocr.txt"),". Now, it's finally time to answer this question."),Object(o.b)("h4",null,"Constructing a Google Search URL and Launching Chrome"),Object(o.b)("p",null,"One little nasty step we have to do is to put our URL-encoded search query into a Google Search URL and then push that URL to a browser of choice (I used Google Chrome). I used Python for this step because of its familiarity."),Object(o.b)("h4",null,"URL Encoding the Search Query"),Object(o.b)("p",null,"A typical Google search URL looks something like this:"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("em",{parentName:"p"},Object(o.b)("a",i({parentName:"em"},{href:"https://www.google.com/search&q=what+is+life%3F"}),"https://www.google.com/search&q=what+is+life%3F")))),Object(o.b)("p",null,"Notice how the search query is a query string, the spaces are replaced with ",Object(o.b)("inlineCode",{parentName:"p"},"+")," signs, and special characters are encoded. Python 3 can do this easily with ",Object(o.b)("inlineCode",{parentName:"p"},"urllib.parse.quote_plus(str)"),"."),Object(o.b)("p",null,"So our code might look something like this:"),Object(o.b)("pre",i({},{className:"language-python"}),Object(o.b)("code",i({parentName:"pre"},{className:"language-python"}),"query_encoded ",Object(o.b)("span",i({parentName:"code"},{className:"token operator"}),"=")," urllib",Object(o.b)("span",i({parentName:"code"},{className:"token punctuation"}),"."),"parse",Object(o.b)("span",i({parentName:"code"},{className:"token punctuation"}),"."),"quote_plus",Object(o.b)("span",i({parentName:"code"},{className:"token punctuation"}),"("),"query",Object(o.b)("span",i({parentName:"code"},{className:"token punctuation"}),")"),"\n")),Object(o.b)("h4",null,"Programmatically Launching Chrome"),Object(o.b)("p",null,"Now, we need to pass the URL to Chrome programmatically. With a little bit of trial and error, I found out that the Unix binary, located at ",Object(o.b)("inlineCode",{parentName:"p"},"/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome"),", can open URLs without launching a new browser instance. Using that to our advantage, we simply pass the URL as a shell argument, and ",Object(o.b)("em",{parentName:"p"},"viol\xe0!")," It works."),Object(o.b)("h4",null,"Stitching These Components Together"),Object(o.b)("p",null,"Now, it's time to mesh these components together. I decided to keep it simple and created a shell script to run each component and pass around data. My shell script ended up looking like this:"),Object(o.b)("pre",i({},{className:"language-bash"}),Object(o.b)("code",i({parentName:"pre"},{className:"language-bash"}),Object(o.b)("span",i({parentName:"code"},{className:"token shebang important"}),"#!/usr/local/bin/zsh"),"\n",Object(o.b)("span",i({parentName:"code"},{className:"token builtin class-name"}),"echo")," ",Object(o.b)("span",i({parentName:"code"},{className:"token string"}),'"Realtime Screen OCR"'),"\n",Object(o.b)("span",i({parentName:"code"},{className:"token keyword"}),"while")," ",Object(o.b)("span",i({parentName:"code"},{className:"token boolean"}),"true"),"\n",Object(o.b)("span",i({parentName:"code"},{className:"token keyword"}),"do"),"\n    ",Object(o.b)("span",i({parentName:"code"},{className:"token builtin class-name"}),"echo")," ",Object(o.b)("span",i({parentName:"code"},{className:"token string"}),'"Waiting for trigger"'),"\n    ",Object(o.b)("span",i({parentName:"code"},{className:"token builtin class-name"}),"read"),"\n    screencapture -Rx,y,w,h screens.png\n    tesseract screens.png ocr\n    ",Object(o.b)("span",i({parentName:"code"},{className:"token assign-left variable"}),"OCR"),Object(o.b)("span",i({parentName:"code"},{className:"token operator"}),"="),Object(o.b)("span",i({parentName:"code"},{className:"token variable"}),Object(o.b)("span",i({parentName:"span"},{className:"token variable"}),"`"),Object(o.b)("span",i({parentName:"span"},{className:"token function"}),"cat")," ocr.txt",Object(o.b)("span",i({parentName:"span"},{className:"token variable"}),"`")),"\n    python3 launch.py ",Object(o.b)("span",i({parentName:"code"},{className:"token variable"}),"$OCR"),"\n    ",Object(o.b)("span",i({parentName:"code"},{className:"token builtin class-name"}),"echo")," ",Object(o.b)("span",i({parentName:"code"},{className:"token string"}),'"Opened Chrome...waiting for next question"'),"\n",Object(o.b)("span",i({parentName:"code"},{className:"token keyword"}),"done"),"\n")),Object(o.b)("p",null,"The script waits for the enter key, grabs the predefined rect, runs OCR on it, and then launches Chrome. Then, it goes back to waiting for the enter key."),Object(o.b)("h3",null,"Testing and Debrief"),Object(o.b)("p",null,"I ran tests on this system using video replays of previous HQ Trivia shows. It worked well but struggled on the more difficult questions. Here's a video of the system providing an instant answer to a question:"),Object(o.b)("center",null,Object(o.b)("iframe",{width:"560",height:"315",src:"https://www.youtube-nocookie.com/embed/F1m6ZyqIvhs?rel=0",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),Object(o.b)("p",null,"In my opinion, this checks all the boxes\u2013it works offline, it's fast, and it's pretty much self-sufficient."),Object(o.b)("p",null,"However, it's not always 100% accurate. This is because I didn't develop an ",Object(o.b)("em",{parentName:"p"},"actual")," QAS system that breaks down sentence structure using NLP and then searches for detected entities within a corpus. But this shows that ",Object(o.b)("em",{parentName:"p"},"it's possible to build something like this.")," This system took me one hour to build from planning to completion; somebody with more time and dedication could build something even more accurate and scam the companies behind these apps for thousands of dollars."),Object(o.b)("h2",null,"Defending Against Cheaters"),Object(o.b)("p",null,"Preventing people from cheating, especially on devices they own, is extremely difficult. ",Object(o.b)("a",i({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Sony_BMG_copy_protection_rootkit_scandal"}),"It's also quite difficult to do right.")," The dev mentioned in the Introduction, Toby Mellor, suggests a software check for screen capture devices. While a good first step, this doesn't really prevent alternative methods of screen capture (such as just straight-up filming the screen with another camera). I suggest ",Object(o.b)("em",{parentName:"p"},"fooling the underlying algorithms underneath"),"."),Object(o.b)("p",null,'"How do you do this", you may ask? The answer is ',Object(o.b)("em",{parentName:"p"},"adversarial perturbations"),", a term coined by Evtimov et al. in the paper ",Object(o.b)("em",{parentName:"p"},Object(o.b)("a",i({parentName:"em"},{href:"https://arxiv.org/abs/1707.08945"}),"Robust Physical-World Attacks on Deep Learning Models")),". By making the text harder to be read by a bot, you are esssentially rate-limiting cheating. So how would this look like in practice? Maybe something like this, which completely fooled Tesseract:"),Object(o.b)("center",null,Object(o.b)("img",{src:"/static/img/hq-fooled.png",alt:"A more confusing picture"})),Object(o.b)("p",null,"(Well, not exactly that. That picture is quite horrible aesthetically)"),Object(o.b)("p",null,"HQ needs to take advantage of its animated aesthetic and add a pattern, different fonts, particle effects, or something similar to confuse OCR systems."),Object(o.b)("p",null,"There's already been research into how to fool OCR systems, such as this ",Object(o.b)("a",i({parentName:"p"},{href:"https://walkerart.org/magazine/sang-mun-defiant-typeface-nsa-privacy"}),"OCR-resistant font"),", but I think that with the advent of deep learning, nothing short of overlaying/blending unpredictable patterns will prevent determined attackers from developing systems to cheat."),Object(o.b)("p",null,Object(o.b)("a",i({parentName:"p"},{href:"https://news.ycombinator.com/item?id=15944171"}),"Discuss on Hacker News")))}p.isMDXComponent=!0},rePB:function(e,t,n){"use strict";function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}n.d(t,"a",(function(){return a}))}},[["GUIJ",0,1]]]);