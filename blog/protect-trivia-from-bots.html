<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Aditya Rathod | Protecting Trivia Apps from Cheaters</title><meta name="robots" content="index,follow"/><meta name="description" content="How people cheat at trivia games, and how the companies running them could stop this from happening."/><meta property="og:title" content="Aditya Rathod | Protecting Trivia Apps from Cheaters"/><meta property="og:description" content="How people cheat at trivia games, and how the companies running them could stop this from happening."/><meta property="og:type" content="article"/><meta property="article:published_time" content="2017-12-17T01:00:00.000Z"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/dd67a8de90d82862.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dd67a8de90d82862.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-b6ae7f85f00af153.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1b961b81afafe8a2.js" defer=""></script><script src="/_next/static/chunks/675-8610370ef62a12c1.js" defer=""></script><script src="/_next/static/chunks/845-4fd11481df1204c1.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-c0bf3d55c00ed0d2.js" defer=""></script><script src="/_next/static/aSyoPV7O50QT6mPbepoKW/_buildManifest.js" defer=""></script><script src="/_next/static/aSyoPV7O50QT6mPbepoKW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><section><div class="w-full bg-cyan h-[3px]"></div><header class="mt-3 px-8 py-3 mx-auto flex flex-row items-center justify-between sm:justify-between md:justify-start lg:justify-start xl:justify-start"><div class="mr-0 sm:mr-0 md:mr-8 lg:mr-10 xl:mr-10 text-center"><a class="font-bold text-2xl text-white opacity-100 hover:opacity-80" href="/">Aditya Rathod<span class="text-spring">.</span></a></div><div class="flex-1"></div><nav class="hidden sm:hidden md:flex lg:flex xl:flex flaex-1 flex-row items-center"><a class="text-white text-md opacity-80 hover:opacity-100 transition-opacity ml-10" href="/#projects">Projects</a><a class="text-white text-md opacity-80 hover:opacity-100 transition-opacity ml-10" href="/writing">Writing</a><a href="/resume.pdf" class="text-white text-md opacity-80 hover:opacity-100 transition-opacity ml-10">Resume</a></nav></header><nav class="mt-2 pl-8 flex sm:flex md:hidden flex-1 flex-row items-a"><a class="text-white text-md opacity-80 hover:opacity-100 transition-opacity mr-10" href="/#projects">Projects</a><a class="text-white text-md opacity-80 hover:opacity-100 transition-opacity mr-10" href="/writing">Writing</a><a href="/resume.pdf" class="text-white text-md opacity-80 hover:opacity-100 transition-opacity mr-10">Resume</a></nav></section><div class="py-10 px-8 max-w-6xl"><article><div class="post-header mb-8"><h1 class="text-3xl mb-1 font-semibold">Protecting Trivia Apps from Cheaters</h1><h3 class="text-md text-cyan uppercase mb-3 font-semibold">December 16, 2017</h3><a class="inline mr-2 py-1 px-2 rounded-sm bg-gray-800 text-white text-xs hover:text-gray-300" href="/writing?tag=Legacy%20Content">Legacy Content</a></div><main class="prose prose-invert max-w-none prose-pre:bg-transparent prose-pre:p-0 prose-code:before:content-[&#x27;&#x27;] prose-code:after:content-[&#x27;&#x27;] prose-p:text-white prose-a:text-cyan hover:prose-a:text-white hover:prose-a:underline prose-a:no-underline"><p><em>This article has been mentioned in the media: <a href="https://www.theverge.com/2017/12/25/16817502/how-to-stop-hq-cheaters">The Verge</a>, <a href="https://www.washingtonpost.com/graphics/2018/business/hq-trivia/">Washington Post</a>, and <a href="https://techcrunch.com/2018/03/06/hq-trivia-questions/">TechCrunch</a></em>.</p>
<p><em>Mobile trivia apps</em>, such as HQ Trivia and The Q, modernize game show-style entertainment, allowing anyone to try their hand at winning cash prizes from their smartphone from anywhere. However, these applications are susceptible to cheaters and bots. For example, <a href="https://medium.com/@tobymellor/hq-trivia-using-bots-to-win-money-from-online-game-shows-ce2a1b11828b">a developer by the name of Toby Mellor</a> recently demonstrated how he created a near-realtime system to cheat on HQ Trivia. His post (linked above) details his use of Google cloud APIs to create this system.</p>
<p>While the demo was certainly impressive, I felt that I could improve on this system as a proof-of-concept. Armed with his post, I set out to make a better version of his system. However, I set some constraints on myself to make this more of a challenge:</p>
<ul>
<li>The system must run offline, with the exception of the QAS (question-and-answer system).</li>
<li>The system allow a human enough time to tap in the answer.</li>
<li>The system should require minimal human intervention, since a human will be using the system in real time.</li>
<li>The system must be functional within one hour.</li>
</ul>
<h2>Creating a Trivia-Cheating System</h2>
<h3>Design</h3>
<p>Instead of doing fancy (and slow) network-request hijacking using <code>mitmproxy</code>, I decided to run OCR at intervals on a portion of the image coming from the phone and pipe that to Google to provide a quick answer for the human operator to tap in. The system looks something like the following:</p>
<img alt="trivia diagram" src="/post-images/trivia-diagram-2.png" width="700" height="85" decoding="async" data-nimg="1" class="mx-auto" loading="lazy" style="color:transparent;width:100%;height:auto"/>
<p>TL;DR: a region of the iPhone&#x27;s screen will get captured, put through OCR, and then searched up on Google to get an answer.</p>
<h3>Implementation</h3>
<h4>Capturing the Screen</h4>
<p>First, I needed a way to capture only a region of the QuickTime window on my Mac into a temp file. That turned out to be trivial using the excellent CLI <code>screencapture</code> tool.</p>
<p>I initially used interactive selection, where the user manually makes a rectangular selection to capture:</p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code class="language-bash" style="white-space:pre"><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:1.25em;padding-right:1em;text-align:right;user-select:none">1</span><span>screencapture -ci screens.png</span></span></code></div></pre>
<p>However, I quickly realized that was extremely inefficient and that hardcoding in rect coordinates (a feature <code>screencapture</code> supports) was a much better option:</p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code class="language-bash" style="white-space:pre"><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:1.25em;padding-right:1em;text-align:right;user-select:none">1</span><span> screencapture -Rx,y,w,h screens.png</span></span></code></div></pre>
<p><em>Note:</em> The rect coordinates are in the form <code>x,y,w,h</code>, with <code>(x, y)</code> being the coordinate of the top left corner.</p>
<h4>Optical Character Recognition</h4>
<p>It was time to find a passable OCR system that was fast and accurate. The only one I could think of was <a href="https://github.com/tesseract-ocr/tesseract"><code>tesseract</code></a>, an OCR engine maintained by Google. While not the best system in the world, its functionality out of the box was pretty great in my testing.</p>
<p>In order to extract text from our image using Tesseract, I used the following,</p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code class="language-bash" style="white-space:pre"><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:1.25em;padding-right:1em;text-align:right;user-select:none">1</span><span>tesseract screens.png ocr</span></span></code></div></pre>
<p>which takes the image and puts the extracted text into a file, <code>ocr.txt</code>. Now, it&#x27;s finally time to answer this question.</p>
<h4>Constructing a Google Search URL and Launching Chrome</h4>
<p>One little nasty step we have to do is to put our URL-encoded search query into a Google Search URL and then push that URL to a browser of choice (I used Google Chrome). I used Python for this step because of its familiarity.</p>
<h4>URL Encoding the Search Query</h4>
<p>A typical Google search URL looks something like this:</p>
<blockquote>
<p><em><a href="https://www.google.com/search&amp;q=what+is+life%3F">https://www.google.com/search&amp;q=what+is+life%3F</a></em></p>
</blockquote>
<p>Notice how the search query is a query string, the spaces are replaced with <code>+</code> signs, and special characters are encoded. Python 3 can do this easily with <code>urllib.parse.quote_plus(str)</code>.</p>
<p>So our code might look something like this:</p>
<pre><div style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code class="language-python" style="white-space:pre"><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:1.25em;padding-right:1em;text-align:right;user-select:none">1</span><span>query_encoded = urllib.parse.quote_plus(query)</span></span></code></div></pre>
<h4>Programmatically Launching Chrome</h4>
<p>Now, we need to pass the URL to Chrome programmatically. With a little bit of trial and error, I found out that the Unix binary, located at <code>/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome</code>, can open URLs without launching a new browser instance. Using that to our advantage, we simply pass the URL as a shell argument, and <em>violà!</em> It works.</p>
<h4>Stitching These Components Together</h4>
<p>Now, it&#x27;s time to mesh these components together. I decided to keep it simple and created a shell script to run each component and pass around data. My shell script ended up looking like this:</p>
<section class="w-full p-2 bg-gray-700 rounded-md"><div class="flex flex-row mb-2"><button class="py-2 px-4 bg-gray-900 min-w-[150px] rounded-md mr-4">realtime-ocr.bash</button></div><pre name="realtime-ocr.bash" content="#!/usr/local/bin/zsh
echo &quot;Realtime Screen OCR&quot;
while true
do
    echo &quot;Waiting for trigger&quot;
    read
    screencapture -Rx,y,w,h screens.png
    tesseract screens.png ocr
    OCR=`cat ocr.txt`
    python3 launch.py $OCR
    echo &quot;Opened Chrome...waiting for next question&quot;
done" style="display:block;overflow-x:auto;padding:1rem;color:#abb2bf;background:#282c34;margin:0;border-radius:0.375rem"><code class="language-bash" style="white-space:pre"><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">1</span><span style="color:#61aeee">#!/usr/local/bin/zsh</span><span>
</span></span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">2</span><span></span><span style="color:#e6c07b">echo</span><span> </span><span style="color:#98c379">&quot;Realtime Screen OCR&quot;</span><span>
</span></span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">3</span><span></span><span style="color:#c678dd">while</span><span> </span><span style="color:#56b6c2">true</span><span>
</span></span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">4</span><span></span><span style="color:#c678dd">do</span><span>
</span></span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">5</span><span>    </span><span style="color:#e6c07b">echo</span><span> </span><span style="color:#98c379">&quot;Waiting for trigger&quot;</span><span>
</span></span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">6</span><span>    </span><span style="color:#e6c07b">read</span><span>
</span></span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">7</span>    screencapture -Rx,y,w,h screens.png
</span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">8</span>    tesseract screens.png ocr
</span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">9</span>    OCR=`cat ocr.txt`
</span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">10</span><span>    python3 launch.py </span><span style="color:#d19a66">$OCR</span><span>
</span></span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">11</span><span>    </span><span style="color:#e6c07b">echo</span><span> </span><span style="color:#98c379">&quot;Opened Chrome...waiting for next question&quot;</span><span>
</span></span><span><span class="comment linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none">12</span><span></span><span style="color:#c678dd">done</span></span></code></pre></section>
<p>The script waits for the enter key, grabs the predefined rect, runs OCR on it, and then launches Chrome. Then, it goes back to waiting for the enter key.</p>
<h3>Testing and Debrief</h3>
<p>I ran tests on this system using video replays of previous HQ Trivia shows. It worked well but struggled on the more difficult questions. Here&#x27;s a video of the system providing an instant answer to a question:</p>
<center><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/F1m6ZyqIvhs?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></center>
<p>In my opinion, this checks all the boxes–it works offline, it&#x27;s fast, and it&#x27;s pretty much self-sufficient.</p>
<p>However, it&#x27;s not always 100% accurate. This is because I didn&#x27;t develop an <em>actual</em> QAS system that breaks down sentence structure using NLP and then searches for detected entities within a corpus. But this shows that <em>it&#x27;s possible to build something like this.</em> This system took me one hour to build from planning to completion; somebody with more time and dedication could build something even more accurate and scam the companies behind these apps for thousands of dollars.</p>
<h2>Defending Against Cheaters</h2>
<p>Preventing people from cheating, especially on devices they own, is extremely difficult. <a href="https://en.wikipedia.org/wiki/Sony_BMG_copy_protection_rootkit_scandal">It&#x27;s also quite difficult to do right.</a> The dev mentioned in the Introduction, Toby Mellor, suggests a software check for screen capture devices. While a good first step, this doesn&#x27;t really prevent alternative methods of screen capture (such as just straight-up filming the screen with another camera). I suggest <em>fooling the underlying algorithms underneath</em>.</p>
<p>&quot;How do you do this&quot;, you may ask? The answer is <em>adversarial perturbations</em>, a term coined by Evtimov et al. in the paper <em><a href="https://arxiv.org/abs/1707.08945">Robust Physical-World Attacks on Deep Learning Models</a></em>. By making the text harder to be read by a bot, you are esssentially rate-limiting cheating. So how would this look like in practice? Maybe something like this, which completely fooled Tesseract:</p>
<img src="/post-images/hq-fooled.png" width="400" height="500" decoding="async" data-nimg="1" class="mx-auto" loading="lazy" style="color:transparent"/>
<p>(Well, not exactly that. That picture is quite horrible aesthetically)</p>
<p>HQ needs to take advantage of its animated aesthetic and add a pattern, different fonts, particle effects, or something similar to confuse OCR systems.</p>
<p>There&#x27;s already been research into how to fool OCR systems, such as this <a href="https://walkerart.org/magazine/sang-mun-defiant-typeface-nsa-privacy">OCR-resistant font</a>, but I think that with the advent of deep learning, nothing short of overlaying/blending unpredictable patterns will prevent determined attackers from developing systems to cheat.</p>
<p><a href="https://news.ycombinator.com/item?id=15944171">Discuss on Hacker News</a></p></main></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    code: \"code\",\n    h4: \"h4\",\n    pre: \"pre\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components), {Image, MultiCode} = _components;\n  if (!Image) _missingMdxReference(\"Image\", true);\n  if (!MultiCode) _missingMdxReference(\"MultiCode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsxs(_components.em, {\n        children: [\"This article has been mentioned in the media: \", _jsx(_components.a, {\n          href: \"https://www.theverge.com/2017/12/25/16817502/how-to-stop-hq-cheaters\",\n          children: \"The Verge\"\n        }), \", \", _jsx(_components.a, {\n          href: \"https://www.washingtonpost.com/graphics/2018/business/hq-trivia/\",\n          children: \"Washington Post\"\n        }), \", and \", _jsx(_components.a, {\n          href: \"https://techcrunch.com/2018/03/06/hq-trivia-questions/\",\n          children: \"TechCrunch\"\n        })]\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Mobile trivia apps\"\n      }), \", such as HQ Trivia and The Q, modernize game show-style entertainment, allowing anyone to try their hand at winning cash prizes from their smartphone from anywhere. However, these applications are susceptible to cheaters and bots. For example, \", _jsx(_components.a, {\n        href: \"https://medium.com/@tobymellor/hq-trivia-using-bots-to-win-money-from-online-game-shows-ce2a1b11828b\",\n        children: \"a developer by the name of Toby Mellor\"\n      }), \" recently demonstrated how he created a near-realtime system to cheat on HQ Trivia. His post (linked above) details his use of Google cloud APIs to create this system.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"While the demo was certainly impressive, I felt that I could improve on this system as a proof-of-concept. Armed with his post, I set out to make a better version of his system. However, I set some constraints on myself to make this more of a challenge:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"The system must run offline, with the exception of the QAS (question-and-answer system).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The system allow a human enough time to tap in the answer.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The system should require minimal human intervention, since a human will be using the system in real time.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The system must be functional within one hour.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Creating a Trivia-Cheating System\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Design\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Instead of doing fancy (and slow) network-request hijacking using \", _jsx(_components.code, {\n        children: \"mitmproxy\"\n      }), \", I decided to run OCR at intervals on a portion of the image coming from the phone and pipe that to Google to provide a quick answer for the human operator to tap in. The system looks something like the following:\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/post-images/trivia-diagram-2.png\",\n      width: 700,\n      height: 85,\n      className: \"mx-auto\",\n      layout: \"responsive\",\n      alt: \"trivia diagram\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TL;DR: a region of the iPhone's screen will get captured, put through OCR, and then searched up on Google to get an answer.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Implementation\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Capturing the Screen\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, I needed a way to capture only a region of the QuickTime window on my Mac into a temp file. That turned out to be trivial using the excellent CLI \", _jsx(_components.code, {\n        children: \"screencapture\"\n      }), \" tool.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I initially used interactive selection, where the user manually makes a rectangular selection to capture:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"screencapture -ci screens.png\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, I quickly realized that was extremely inefficient and that hardcoding in rect coordinates (a feature \", _jsx(_components.code, {\n        children: \"screencapture\"\n      }), \" supports) was a much better option:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \" screencapture -Rx,y,w,h screens.png\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Note:\"\n      }), \" The rect coordinates are in the form \", _jsx(_components.code, {\n        children: \"x,y,w,h\"\n      }), \", with \", _jsx(_components.code, {\n        children: \"(x, y)\"\n      }), \" being the coordinate of the top left corner.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Optical Character Recognition\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It was time to find a passable OCR system that was fast and accurate. The only one I could think of was \", _jsx(_components.a, {\n        href: \"https://github.com/tesseract-ocr/tesseract\",\n        children: _jsx(_components.code, {\n          children: \"tesseract\"\n        })\n      }), \", an OCR engine maintained by Google. While not the best system in the world, its functionality out of the box was pretty great in my testing.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In order to extract text from our image using Tesseract, I used the following,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"tesseract screens.png ocr\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"which takes the image and puts the extracted text into a file, \", _jsx(_components.code, {\n        children: \"ocr.txt\"\n      }), \". Now, it's finally time to answer this question.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Constructing a Google Search URL and Launching Chrome\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One little nasty step we have to do is to put our URL-encoded search query into a Google Search URL and then push that URL to a browser of choice (I used Google Chrome). I used Python for this step because of its familiarity.\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"URL Encoding the Search Query\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A typical Google search URL looks something like this:\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"https://www.google.com/search\u0026q=what+is+life%3F\",\n            children: \"https://www.google.com/search\u0026q=what+is+life%3F\"\n          })\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Notice how the search query is a query string, the spaces are replaced with \", _jsx(_components.code, {\n        children: \"+\"\n      }), \" signs, and special characters are encoded. Python 3 can do this easily with \", _jsx(_components.code, {\n        children: \"urllib.parse.quote_plus(str)\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So our code might look something like this:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"query_encoded = urllib.parse.quote_plus(query)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Programmatically Launching Chrome\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, we need to pass the URL to Chrome programmatically. With a little bit of trial and error, I found out that the Unix binary, located at \", _jsx(_components.code, {\n        children: \"/Applications/Google\\\\ Chrome.app/Contents/MacOS/Google\\\\ Chrome\"\n      }), \", can open URLs without launching a new browser instance. Using that to our advantage, we simply pass the URL as a shell argument, and \", _jsx(_components.em, {\n        children: \"violà!\"\n      }), \" It works.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Stitching These Components Together\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, it's time to mesh these components together. I decided to keep it simple and created a shell script to run each component and pass around data. My shell script ended up looking like this:\"\n    }), \"\\n\", _jsx(MultiCode, {\n      tabs: [{\n        name: \"realtime-ocr.bash\",\n        content: `#!/usr/local/bin/zsh\necho \"Realtime Screen OCR\"\nwhile true\ndo\n    echo \"Waiting for trigger\"\n    read\n    screencapture -Rx,y,w,h screens.png\n    tesseract screens.png ocr\n    OCR=\\`cat ocr.txt\\`\n    python3 launch.py $OCR\n    echo \"Opened Chrome...waiting for next question\"\ndone`,\n        language: \"bash\"\n      }]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The script waits for the enter key, grabs the predefined rect, runs OCR on it, and then launches Chrome. Then, it goes back to waiting for the enter key.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Testing and Debrief\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I ran tests on this system using video replays of previous HQ Trivia shows. It worked well but struggled on the more difficult questions. Here's a video of the system providing an instant answer to a question:\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"iframe\", {\n        width: \"560\",\n        height: \"315\",\n        src: \"https://www.youtube-nocookie.com/embed/F1m6ZyqIvhs?rel=0\",\n        frameborder: \"0\",\n        allow: \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\",\n        allowfullscreen: true\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In my opinion, this checks all the boxes–it works offline, it's fast, and it's pretty much self-sufficient.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, it's not always 100% accurate. This is because I didn't develop an \", _jsx(_components.em, {\n        children: \"actual\"\n      }), \" QAS system that breaks down sentence structure using NLP and then searches for detected entities within a corpus. But this shows that \", _jsx(_components.em, {\n        children: \"it's possible to build something like this.\"\n      }), \" This system took me one hour to build from planning to completion; somebody with more time and dedication could build something even more accurate and scam the companies behind these apps for thousands of dollars.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Defending Against Cheaters\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Preventing people from cheating, especially on devices they own, is extremely difficult. \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Sony_BMG_copy_protection_rootkit_scandal\",\n        children: \"It's also quite difficult to do right.\"\n      }), \" The dev mentioned in the Introduction, Toby Mellor, suggests a software check for screen capture devices. While a good first step, this doesn't really prevent alternative methods of screen capture (such as just straight-up filming the screen with another camera). I suggest \", _jsx(_components.em, {\n        children: \"fooling the underlying algorithms underneath\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\"How do you do this\\\", you may ask? The answer is \", _jsx(_components.em, {\n        children: \"adversarial perturbations\"\n      }), \", a term coined by Evtimov et al. in the paper \", _jsx(_components.em, {\n        children: _jsx(_components.a, {\n          href: \"https://arxiv.org/abs/1707.08945\",\n          children: \"Robust Physical-World Attacks on Deep Learning Models\"\n        })\n      }), \". By making the text harder to be read by a bot, you are esssentially rate-limiting cheating. So how would this look like in practice? Maybe something like this, which completely fooled Tesseract:\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/post-images/hq-fooled.png\",\n      width: 400,\n      height: 500,\n      className: \"mx-auto\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(Well, not exactly that. That picture is quite horrible aesthetically)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HQ needs to take advantage of its animated aesthetic and add a pattern, different fonts, particle effects, or something similar to confuse OCR systems.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There's already been research into how to fool OCR systems, such as this \", _jsx(_components.a, {\n        href: \"https://walkerart.org/magazine/sang-mun-defiant-typeface-nsa-privacy\",\n        children: \"OCR-resistant font\"\n      }), \", but I think that with the advent of deep learning, nothing short of overlaying/blending unpredictable patterns will prevent determined attackers from developing systems to cheat.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://news.ycombinator.com/item?id=15944171\",\n        children: \"Discuss on Hacker News\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Protecting Trivia Apps from Cheaters","description":"How people cheat at trivia games, and how the companies running them could stop this from happening.","displayDate":"December 16, 2017","date":1513472400000,"tags":["Legacy Content"]}},"frontMatter":{"title":"Protecting Trivia Apps from Cheaters","description":"How people cheat at trivia games, and how the companies running them could stop this from happening.","displayDate":"December 16, 2017","date":1513472400000,"tags":["Legacy Content"]}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"protect-trivia-from-bots"},"buildId":"aSyoPV7O50QT6mPbepoKW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>